{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACRA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://abott/./src/constants/trigger.js","../webpack://abott/./src/lib/asana.js","../webpack://abott/./src/lib/git.js","../webpack://abott/./src/utils/utils.js","../webpack://abott/../../.nvm/versions/node/v16.17.1/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://abott/webpack/bootstrap","../webpack://abott/webpack/runtime/compat","../webpack://abott/./index.js"],"sourcesContent":["const triggers = [\n  'pull_request',\n  'pull_request_review',\n  'pull_request_review_comment',\n];\n\nmodule.exports = triggers;","const asana = require('asana');\nconst core = require('@actions/core');\n\nconst asanaBot = async (asanaPat, taskID, target, prState, prUrl, prTitle, prNumber, commentStatus, doNotMoveSections) => {\n  const client = asana.Client.create({\n    'defaultHeaders': {\n      'asana-enable': 'new_user_task_lists',\n    },\n  }).useAccessToken(asanaPat);\n\n  core.debug(`TaskID: ${taskID}`);\n  try {\n    const task = await client.tasks.findById(taskID);\n    const projects = task.projects;\n    target = JSON.parse(target);\n    let out = [];\n    let foundFlag = false;\n    for (const proj of projects) {\n      const sections = await client.sections.findByProject(proj.gid);\n  \n      doNotMoveSections = JSON.parse(doNotMoveSections);\n      if (doNotMoveSections.length > 0) {\n        for (const members of task.memberships) {\n          if (members.project.gid === proj.gid) {\n            for (const doNotSec of doNotMoveSections) {\n              if (members.section.gid === doNotSec) {\n                continue\n              } \n            }\n          }\n        }\n      }\n  \n      try {\n        const targetSection = await sections.find((sec) => sec.name === target[prState]);\n        if (targetSection) {\n          foundFlag = true;\n          await client.sections.addTask(targetSection.gid, { task: taskID });\n          out.push(`Moved ${task.name} to ${targetSection.name} in ${proj.name}`);\n        } else {\n          out.push(`Unable to move ${task.name} to ${target[prState]} in ${proj.name} as section doesn't exist.`)\n        }\n      } catch(err) {\n        core.debug(err);\n        out.push(`Unable to move ${task.name} to ${target[prState]} in ${proj.name} as section doesn't exist.`)\n      }\n    }\n  \n    if (commentStatus) {\n      let comment;\n      if (prState === 'OPEN') {\n        comment = {\n          text: `🔓 PR opened\\n--------\\n${prTitle}\\n------------\\nView: ${prUrl}`\n        };\n      }\n  \n      await client.tasks.addComment(taskID, comment);\n    }\n  \n    if (prState === 'CLOSED') {\n      await client.tasks.addComment(taskID, {\n        text: `🛑 Closed Pull Request #${prNumber}.\\n View: ${prUrl}`,\n      });\n    } else if (prState === 'MERGED') {\n      await client.tasks.addComment(taskID, {\n        text: `🎉 Merged Pull Request #${prNumber}\\n${prTitle}\\nView: ${prUrl}`,\n      });\n    } else if (prState === 'CHANGES_REQUESTED') {\n      await client.tasks.addComment(taskID, {\n        text: `❌ Changes request for PR #${prNumber}\\n-> View: ${prUrl}`,\n      });\n    } else if (prState === 'APPROVED') {\n      await client.tasks.addComment(taskID, {\n        text: `✅ PR Approved\\n-------------------\\n${prTitle}\\n-------------------\\nView: ${prUrl}`\n      });\n    }\n  \n    if (!foundFlag) {\n      return [`No tasks found for the project and the sections mentioned`];\n    } else {\n      return out;\n    }\n  } catch (err) {\n    core.debug(err);\n  }\n};\n\nmodule.exports = asanaBot;","const core = require('@actions/core');\nconst bot = require('./asana');\nconst axios = require('axios');\n\nconst gitEvent = async (asanaPAT, asanaSecret, pr, target, prState, doNotMoveSections) => {\n  const ASANA_TASK_LINK_REGEX = /https:\\/\\/app.asana.com\\/(\\d+)\\/(?<project>\\d+)\\/(?<taskId>\\d+).*/ig;\n  if (pr != null) {\n    core.info('Handling PR event...');\n    const prUrl = pr.html_url;\n    // const prIsMerged = pr.merged;\n    const prBody = pr.body;\n    const prNumber = pr.number;\n    const prTitle = pr.title;\n\n    let taskIDs = [];\n    let rawParseUrlTask;\n    let res;\n    core.debug(prBody);\n    while ((rawParseUrlTask = ASANA_TASK_LINK_REGEX.exec(prBody)) !== null) {\n      taskIDs.push(rawParseUrlTask.groups.taskId);\n    }\n\n    core.info(taskIDs);\n\n    for (const taskID of taskIDs) {\n      let commentStatus = true;\n      if (asanaSecret !== '') {\n        // This happens only when the PR is created. Otherwise we don't need to link the issue\n        if (prState === 'OPEN') {\n          const axiosInstance = axios.create({\n            baseURL: 'https://github.integrations.asana.plus/custom/v1',\n            headers: {\n              Authorization: `Bearer ${asanaSecret}`,\n            }\n          });\n\n          const result = await axiosInstance.post('actions/widget', {\n            allowedProjects: [],\n            blockedProjects: [],\n            pullRequestDescription: prBody,\n            pullRequestName: prTitle,\n            pullRequestNumber: prNumber,\n            pullRequestURL: prUrl, \n          });\n    \n          core.info(result.status);\n        }\n        commentStatus = false;\n      } else {\n        commentStatus = true;\n      }\n\n      res = await bot(asanaPAT, taskID, target, prState, prUrl, prTitle, prNumber, commentStatus, doNotMoveSections);\n      core.setOutput('res', res);\n    }\n  }\n};\n\nmodule.exports = gitEvent;\n","const triggers = require('../constants/trigger');\n\nmodule.exports = {\n  validateTrigger: function(eventName) {\n    if (!triggers.includes(eventName)) {\n      throw new Error('Only pull_request, pull_request_review and pull_request_review_comment triggers are supported')\n    }\n  }\n};",null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const github = require('@actions/github');\nconst core = require('@actions/core');\n\nconst utils = require('./src/utils/utils');\nconst git = require('./src/lib/git');\n\nconst run = async () => {\n  utils.validateTrigger(github.context.eventName);\n\n  const action = github.context.payload.action;\n  const pullRequest = github.context.payload.pull_request;\n  let prState = '';\n  const target = core.getInput('target');\n  const asanaPAT = core.getInput('asana_pat');\n  const githubToken = core.getInput('github_token');\n  const asanaSecret = core.getInput('asana_secret');\n  const doNotMoveSections = core.getInput('donot_move');\n\n  const client = github.getOctokit(githubToken);\n  const reviews =  await client.request('GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews', {\n    owner: github.context.repo.owner,\n    repo: github.context.repo.repo,\n    pull_number: github.context.payload.pull_request.number,\n  });\n\n  const prReviews = reviews.data;\n  if (action === 'closed' && pullRequest.merged) {\n    prState = 'MERGED';\n  } else if (prReviews.length > 0) {\n    prState = prReviews[prReviews.length - 1].state.toUpperCase();\n  } else {\n    prState = pullRequest.state.toUpperCase();\n  }\n\n  core.info(prState);\n  await git(asanaPAT, asanaSecret, pullRequest, target, prState, doNotMoveSections);\n}\n\ntry {\n  run();\n} catch(err) {\n  console.log(err);\n  if (err instanceof Error) {\n    core.setFailed(err.message);\n  } else {\n    core.error(err);\n    core.setFailed('Unknown error');\n  }\n}\n"],"names":[],"sourceRoot":""}